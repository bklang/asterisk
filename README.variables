GENERAL ENCHANCEMENTS TO EXTENSION LOGIC : 

QUOTING: 

exten => s,5,BackGround,blabla

The parameter (blabla) can be quoted ("blabla"). In this case, a 
comma does not terminate the field. 

Also, characters special to variable substitution, expression evaluation, etc
(see below), can be quoted. For example, to literally use a $ on the 
string "$1231", quote it with a preceeding \. Special characters that must
be quoted to be used, are [ ] $ " \. (to write \ itself, use \\). 

VARIABLES: 

Parameter strings can include variables. Variable names are arbitrary strings. 
They are stored in the respective channel structure. 

To set a variable to a particular value, do : 

;exten => 1,2,SetVar,varname=value

You can substitute the value of a variable everywhere using ${variablename}.
For example, to stringwise append $lala to $blabla and store result in $koko, 
do: 

;exten => 1,2,SetVar,koko=${blabla}${lala}

There are also the following special variables: 

${CALLERID}	Caller ID
${CALLERIDNAME}	Caller ID Name only
${CALLERIDNUM}	Caller ID Number only
${EXTEN}	Current extension
${CONTEXT}      Current context
${PRIORITY}	Current priority
${CHANNEL}	Current channel name
${ENV(VAR)}	Environmental variable VAR
${LEN(VAR)}	String length of VAR (integer)
${EPOCH}	Current unix style epoch
${DATETIME}	Current date time in the format: YYYY-MM-DD_HH:MM:SS
${UNIQUEID}	Current call unique identifier
${DNID}         Dialed Number Identifier
${RDNIS}        Redirected Dial Number ID Service
${HANGUPCAUSE}	Hangup cause on last PRI hangup

There are two reference modes - reference by value and reference by name. 
To refer to a variable with its name (as an argument to a function that 
requires a variable), just write the name. To refer to the variable's value, 
enclose it inside ${}. For example, SetVar takes as the first argument 
(before the =) a variable name, so: 

;exten => 1,2,SetVar,koko=lala
;exten => 1,3,SetVar,${koko}=blabla

stores to the variable "koko" the value "lala" and to variable "lala" the 
value "blabla". 

In fact, everything contained ${here} is just replaced with the value of 
the variable "here". 

EXPRESSIONS: 

Everything contained inside a bracket pair prefixed by a $ (like $[this]) is 
considered as an expression and it is evaluated. Evaluation works similar to 
(but is done on a later stage than) variable substitution: the expression 
(including the square brackets) is replaced by the result of the expression 
evaluation. The arguments and operands of the expression MUST BE separated 
with spaces (take care NOT to leave ANY spaces between opening and closing 
square brackets and the first and last arguments). 

For example, after the sequence: 

exten => 1,1,SetVar,"lala=$[1 + 2]";
exten => 1,2,SetVar,"koko=$[2 * ${lala}]";

the value of variable koko is "6".

Operators are listed below in order of increasing precedence.  Operators
with equal precedence are grouped within { } symbols.

     expr1 | expr2
             Return the evaluation of expr1 if it is neither an empty string
             nor zero; otherwise, returns the evaluation of expr2.

     expr1 & expr2
             Return the evaluation of expr1 if neither expression evaluates to
             an empty string or zero; otherwise, returns zero.

     expr1 {=, >, >=, <, <=, !=} expr2
             Return the results of integer comparison if both arguments are
             integers; otherwise, returns the results of string comparison
             using the locale-specific collation sequence.  The result of each
             comparison is 1 if the specified relation is true, or 0 if the
             relation is false.

     expr1 {+, -} expr2
             Return the results of addition or subtraction of integer-valued
             arguments.

     expr1 {*, /, %} expr2
             Return the results of multiplication, integer division, or
             remainder of integer-valued arguments.

     expr1 : expr2
             The `:' operator matches expr1 against expr2, which must be a
             regular expression.  The regular expression is anchored to the
             beginning of  the string with an implicit `^'.

             If the match succeeds and the pattern contains at least one regu-
             lar expression subexpression `\(...\)', the string correspond-
             ing to `\1' is returned; otherwise the matching operator
             returns the number of characters matched.  If the match fails and
             the pattern contains a regular expression subexpression the null
             string is returned; otherwise 0.

Parentheses are used for grouping in the usual manner.

The parser must be parsed with bison (bison is REQUIRED - yacc cannot 
produce pure parsers, which are reentrant) 

CONDITIONALS

There is one conditional operator - the conditional goto : 

;exten => 1,2,gotoif,condition?label1:label2

If condition is true go to label1, else go to label2. Labels are interpreted
exactly as in the normal goto command.

"condition" is just a string. If the string is empty or "0", the condition
is considered to be false, if it's anything else, the condition is true. 
This is designed to be used together with the expression syntax described 
above, eg : 

exten => 1,2,gotoif,$[${CALLERID} = 123456]?2|1:3|1


Example of use : 

exten => s,2,SetVar,"vara=1"
exten => s,3,SetVar,"varb=$[${vara} + 2]"
exten => s,4,SetVar,"varc=$[${varb} * 2]"
exten => s,5,GotoIf,"$[${varc} = 6]?99|1:s|6";

